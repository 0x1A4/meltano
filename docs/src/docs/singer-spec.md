---
description: The Open Source Singer Specification 
---

# Singer Spec

The Singer Specification is an open source standard for defining the format of data and information. 
The standard is useful because it enables Data Professionals to move data between arbritrary systems as long as the programs generating and ingesting the data can understand this format.

## Version

The current version of the Spec is 0.3.0. The original documentation is in the [Singer IO](https://github.com/singer-io/getting-started/blob/master/docs/SPEC.md) project on GitHub.

## Basics

### 3 Messages

The full specification for data exchange consists of three types of JSON-formatted messages: `schema`, `record`, and `state`. The `record` message contains the actual data being communicated, the `schema` message defines the structure of the data, and the `state` message keeps track of the progress of an extraction.

An example of what these messages look like is here:

```bash
{"type": "SCHEMA", "stream": "users", "key_properties": ["id"], "schema": {"required": ["id"], "type": "object", "properties": {"id": {"type": "integer"}}}}
{"type": "RECORD", "stream": "users", "record": {"id": 1, "name": "Chris"}}
{"type": "RECORD", "stream": "users", "record": {"id": 2, "name": "Mike"}}
{"type": "SCHEMA", "stream": "locations", "key_properties": ["id"], "schema": {"required": ["id"], "type": "object", "properties": {"id": {"type": "integer"}}}}
{"type": "RECORD", "stream": "locations", "record": {"id": 1, "name": "Philadelphia"}}
{"type": "STATE", "value": {"users": 2, "locations": 1}}
```

Each `record` message contains a `stream` identifier which specifies the unique name of that data. For data coming from an API this can be thought of as the name of the endpoint. For data coming from a database this might be the table name. The `schema` message will have a matching `stream` identifier for the records it describes. The term "stream" will be used in the rest of the documentation to identify a set of data being extracted. 

### Taps

These 3 message types are generated by programs called `taps`. A tap can be written in any programming language (note that Meltano will only run Python-based taps). Taps output the 3 messages to standard output, aka `stdout`.

Taps are required to accept 1 file, called a configuration (config) file, and can optionally accept 2 other files called state and catalog files. 

The config file is a JSON-formatted file containing any information needed for a tap to run. This can include authorization information such as username and password, date parameters to specify when to start extracting, and anything else useful for pulling a specific set of data. 

The state file is a JSON-formatted file used to store information between when taps are run. There is no specification for the format of a state file other than the JSON requirement. If a tap is able to accept a state file it is expected that it will output state messages as well.

The catalog file is a JSON-formatted file that specifies which streams and entities within the streams, such as columns or fields, to extract. It also can define how streams are replicated and can include extra metadata about a particular stream.

### Targets

The 3 message types are consumed by programs called `targets`. A target can be written in any programming language (note that Meltano will only run Python-based targets). Targets ingest the 3 messages from standard input, aka `stdin`

Targets can optionally accept a configuration file if the target system requires authentication information. For a simple target like a csv file, this would not be required, but for a more complicated target like a SaaS database, the config file would be required. 

### Taps | Targets

Since taps and targets are able to communicate to each other via the Singer spec, they can be used together to move data between systems. This can be done on the command line by sending the messages from a tap to a target using a Unix pipe, `|`. A pipe takes information from `stdout` of one process, in this case a tap, and redirects it to `stdin` of a second process, in this case a target. This composability means taps and targets can be composed as simply as `tap | target`.

## Advanced

### Messages

#### Schemas

#### Records

#### State



### Taps

#### Config Files

#### State Files

##### Bookmarks

#### Catalog Files

##### Discovery Mode

##### Metadata

#### Sync/Default Mode

##### Metrics

### Targets

#### Config Files





## Taps and Targets in Meltano


## Definitions

### JSON

[JSON](https://en.wikipedia.org/wiki/JSON) is the abbreviation of JavaScript Object Notation. This is a human-readable data format that is almost universally used in many computing applications. An example JSON object:

    ```json
    {
    "program": "Meltano",
    "protocol": "Singer",
    "is_active": true,
    "age": 3,
    "address": {
        "global": true,
        "streetAddress": null,
        }
    }
    ```

### JSON Schema



### Tap

### Target

### Stream

### Messages

#### State

#### Record

#### Schema
